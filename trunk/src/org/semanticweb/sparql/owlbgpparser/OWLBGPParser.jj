options {
    STATIC=false;
    LOOKAHEAD=2;
    //DEBUG_TOKEN_MANAGER=true;
    //DEBUG_PARSER=true;
}

PARSER_BEGIN(OWLBGPParser)

package org.semanticweb.sparql.owlbgpparser;

import java.io.StringReader;
import java.util.Set;

import org.coode.string.EscapeUtils;
import org.semanticweb.sparql.owlbgp.model.Axiom;
import org.semanticweb.sparql.owlbgp.model.Datatype;
import org.semanticweb.sparql.owlbgp.model.Prefixes;
import org.semanticweb.sparql.owlbgp.model.Datatype.OWL2_DATATYPES;

public class OWLBGPParser {

    protected String base;
    protected int blankNodeId=0;
    protected final TripleHandler handler=new OWLRDFConsumerAdapter();
    protected final Prefixes pm=new Prefixes();
    {
        pm.declareSemanticWebPrefixes();
    }
    public static void main(String[] args) {
//        String s="<http://example.org/Person> rdf:type owl:Class . <http://example.org/Birte> rdf:type <http://example.org/Person> .";
        String s="<http://example.org/Person> rdf:type owl:Class . ?x rdf:type <http://example.org/Person> .";
        OWLBGPParser parser=new OWLBGPParser(new StringReader(s));
        try {
            parser.parse();
            for (Axiom axiom :parser.getParsedAxioms())
                System.out.println(axiom);
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
    
    public boolean isAnonymousNode(String iri) {
        return iri.startsWith("_:");
    }
    public boolean isVariableNode(String iri) {
        return iri.startsWith("?");
    }
    protected String getNextBlankNode() {
        String identifier="_:bn"+blankNodeId;
        blankNodeId++;
        return identifier;
    }
    protected String getIRIFromQName(String qname) throws ParseException {
        int colonIndex=qname.indexOf(':');
        if (colonIndex==-1) throw new ParseException("Not a valid qname (missing ':') " + qname);
        String prefix=qname.substring(0,colonIndex);
        if (prefix.equals("_")) return getNextBlankNode()+"_"+qname.substring(colonIndex + 1);
        if (pm.getPrefixIRI(prefix)==null) throw new ParseException("Prefix not declared: " + prefix);
        return pm.expandAbbreviatedIRI(qname);
    }
    public String getIRI(String s) {
        if (s.charAt(0)=='<') s=s.substring(1,s.length()-1);
        return s.intern();
    }
    public Set<Axiom> getParsedAxioms() {
        return handler.getParsedAxioms();
    }
}

PARSER_END(OWLBGPParser)

SKIP: {" " | "\n" | "\t" | "\r"}

SKIP:
{
    <COMMENT: "#" (~["\n"])*>
}

/////////////////////////////////////////////////////////////////////////////////////////////

MORE : {
    "\"": IN_STRING
}

<IN_STRING> MORE :
{
    <  ("\\\"")|~["\""] >
}

<IN_STRING> TOKEN:
{
    <STRING: "\""> : DEFAULT
}

MORE : {
    "\"\"\"" : IN_LONG_STRING
}

<IN_LONG_STRING> MORE :
{
    <  ~[] >
}


<IN_LONG_STRING> TOKEN :
{
    <LONG_STRING: "\"\"\""> : DEFAULT
}


/////////////////////////////////////////////////////////////////////////////////////////////

TOKEN:
{
    <DIGIT: ["0"-"9"]>
}

TOKEN:
{
    <INTEGER: ("+" | "-")? (<DIGIT>)+>
}

TOKEN:
{
    <DOUBLE: ("-" | "+") ? (<DIGIT>)+ "." (<DIGIT>)* (<EXPONENT> | "." (<DIGIT>)+ <EXPONENT> | (<DIGIT>)+ <EXPONENT>)>
}

TOKEN:
{
    <DECIMAL: ("-" | "+")? ( (<DIGIT>)+ "." (<DIGIT>)* | "." (<DIGIT>)+ | (<DIGIT>)+ )>
}


TOKEN:
{
    <EXPONENT: 	("e" | "E") ("-" | "+")? (<DIGIT>)+>
}


TOKEN:
{
    <OPENPAR: "(">
}

TOKEN:
{
    <CLOSEPAR: ")">
}

TOKEN:
{
    <OPEN_SQUARE_BRACKET: "[">
}

TOKEN:
{
    <CLOSE_SQUARE_BRACKET: "]">
}



TOKEN:
{
    <COMMA: ",">
}

TOKEN:
{
    <DOT: ".">
}

TOKEN:
{
    <SEMICOLON: ";">
}

TOKEN:
{
    <PREFIX: "@prefix">
}

TOKEN:
{
    <DOUBLE_CARET: "^^">
}

TOKEN:
{
    <BASE: "@base">
}

TOKEN:
{
    <AT: "@">
}


TOKEN:
{
    <A: "a">
}


TOKEN:
{
    <EMPTY_BLANK_NODE: <OPEN_SQUARE_BRACKET><CLOSE_SQUARE_BRACKET>>
}

TOKEN:
{
    <NODE_ID_START: "_:">
}

TOKEN:
{
    <TRUE: "true">
}

TOKEN:
{
    <FALSE: "false">
}

TOKEN:
{
    <SELECT: "SELECT">
}

TOKEN:
{
    <WHERE: "WHERE">
}

TOKEN:
{
    <FILTER: "FILTER">
}

TOKEN:
{
    <LETTER: ["a"-"z"] | ["A"-"Z"]>
}



////////////////////////////////////////////////////////////////////////////////////////////
//
// IRIs

TOKEN:
{
    <FULLIRI: "<"(~[">", " "])*">">
}

TOKEN:
{
    <PNAME_NS: (<PN_PREFIX>)? ":">
}


TOKEN:
{
    <PN_LOCAL: ( <PN_CHARS_U> | ["0"-"9"] ) ((<PN_CHARS>|".")* <PN_CHARS>)?>
}

TOKEN:
{
    <PNAME_LN: <PNAME_NS> <PN_LOCAL>>
}

TOKEN:
{
    <PN_PREFIX: <PN_CHARS_BASE>((<PN_CHARS>|".")* <PN_CHARS>)?>
}

TOKEN:
{
    <PN_CHARS_BASE:   ["A"-"Z"]
                    | ["a"-"z"]
                    | ["\u00C0"-"\u00D6"]
                    | ["\u00D8"-"\u00F6"]
                    | ["\u00F8"-"\u02FF"]
                    | ["\u0370"-"\u037D"]
                    | ["\u037F"-"\u1FFF"]
                    | ["\u200C"-"\u200D"]
                    | ["\u2070"-"\u218F"]
                    | ["\u2C00"-"\u2FEF"]
                    | ["\u3001"-"\uD7FF"]
                    | ["\uF900"-"\uFDCF"]
                    | ["\uFDF0"-"\uFFFD"]>
}


TOKEN:
{
    <PN_CHARS:   <PN_CHARS_U>
               | "-"
               | ["0"-"9"]
               | "\u00B7"
               | ["\u0300"-"\u036F"]
               | ["\u203F"-"\u2040"]>
}

TOKEN:
{
    <PN_CHARS_U: <PN_CHARS_BASE> | "_">
}


TOKEN:
{
    <VAR: <VAR1> | <VAR2>> 
}

TOKEN:
{
    <VAR1: "?"<VARNAME>>
}

TOKEN:
{
    <VAR2: "$"<VARNAME>>
}

TOKEN:
{
    <VARNAME:  ( <PN_CHARS_U> | ["0"-"9"] ) (<PN_CHARS_U> | ["0"-"9"] | "\u00B7" | ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"])*>
               
}


TOKEN:
{
    <NODEID: "_:"<PN_LOCAL>>
}


TOKEN:
{
    <ERROR: ~[]>
}

/////////////////////////////////////////////////////////////////////////////////////////////

//TOKEN:
//{
//    <LONG_STRING: (<QUOTE><QUOTE><QUOTE>~["\""]<QUOTE><QUOTE><QUOTE>)>
//}



void parse() :
{
}
{
    
    (parseDirective()<DOT> | parseStatement()<DOT>)+<EOF> {handler.handleEnd();}
}

void parseDirective() :
{
}
{
    parsePrefixDirective() | parseBaseDirective()
}

void parsePrefixDirective() :
{
    Token t;
    String prefix="";
    String ns;
}
{
    <PREFIX> t=<PNAME_NS>{prefix=t.image;} ns=parseIRI() {
        pm.declarePrefix(prefix,ns.toString());
        handler.handlePrefixDirective(prefix, ns.toString());
    }
}

void parseBaseDirective() :
{
    Token t;
}
{
    <BASE> t=<FULLIRI> {base = t.image.substring(1, t.image.length() - 1);} {
        handler.handleBaseDirective(base);
    }
}

void parseStatement() :
{
}
{
    parseTriples()
}

void parseTriples() :
{
    String subject;
}
{
    subject = parseSubject() (parsePredicateObjectList(subject))?
}

String parseSubject() :
{
    String iri;
}
{
    (iri=parseResource() | iri=parseBlankNode() | iri=parseVariable()) {
        return iri;
    }
}

String parseAbbreviatedIRI() :
{
    String iri;
    Token t;
}
{
    t=<PNAME_LN> {
        return getIRIFromQName(t.image);
    }
}

String parseIRI() :
{
    Token t;
    String iri;
}
{
    t=<FULLIRI> {return getIRI(t.image);}
}

String parseBlankNode() :
{
    String iri = null;
}
{
    (iri=parseNodeID()
    |
    <NODEID>{iri = getNextBlankNode();}
    |
    <OPEN_SQUARE_BRACKET> ({iri = getNextBlankNode();} parsePredicateObjectList(iri) (<DOT>)?)? <CLOSE_SQUARE_BRACKET> {if (iri == null) {iri = getNextBlankNode(); }}
    |
    iri = parseCollection()) {
        return iri;
    }
}

String parseNodeID() :
{
    Token t;
}
{
    t=<NODEID> {
        return getIRIFromQName(t.image);
    }
}

String parseVariable() :
{
    String iri;
    Token t;
}
{
    t=<VAR> {
        return t.image;
    }
}

void parsePredicateObjectList(String subject) :
{
    String predicate;
}
{
    (predicate=parseVerb() parseObjectList(subject, predicate) (<SEMICOLON> predicate=parseVerb() parseObjectList(subject, predicate) )*) (<SEMICOLON>)?
}

String parseVerb() :
{
    String iri;
}
{
    (<A>{iri = Vocabulary.RDF_TYPE.getIRI();} | iri=parsePredicate()) {
        return iri;
    }
}

String parsePredicate() :
{
    String iri;
}
{
    (iri=parseResource() | iri=parseVariable()) {
        return iri;
    }
}

String parseResource() :
{
    String iri;
}
{
    (iri=parseIRI() | iri=parseAbbreviatedIRI()) {
        return iri;
    }
}


void parseObjectList(String subject, String predicate) :
{
    
}
{
    parseObject(subject, predicate) ( <COMMA> parseObject(subject, predicate) )*
}

void parseObject(String subject, String predicate) :
{
    String resObject;
}
{
    (parseLiteral(subject, predicate) 
    |
    ((resObject=parseResource()
    |
    resObject=parseBlankNode())
    |
    resObject=parseVariable()) {
        handler.handleTriple(subject, predicate, resObject);
    })
}

String parseCollection() :
{
    String iri;
}
{
    <OPENPAR> iri=parseItemList() <CLOSEPAR> {
        return iri;
    }
}

String parseItemList() :
{
    //  _x  rdf:type rdf:List
    //  _x  rdf:first
    //  _x  rdf:next
    String firstSubject = null;
    String subject = null;
    String type = Vocabulary.RDF_TYPE.getIRI();
    String first = Vocabulary.RDF_FIRST.getIRI();
    String rest = Vocabulary.RDF_REST.getIRI();
    String list = Vocabulary.RDF_LIST.getIRI();
    String nil = Vocabulary.RDF_NIL.getIRI();
}
{
    (
    {
        String prevSubject = subject;
        subject=getNextBlankNode();
        if (prevSubject != null) {
            handler.handleTriple(prevSubject, rest, subject);
        }
        else {
            firstSubject = subject;
        }
        handler.handleTriple(subject, type, list);
    }
        parseObject(subject, first))* {
        // Terminate list
        handler.handleTriple(subject, rest, nil);
        return firstSubject;
    }
}


void parseLiteral(String subject, String predicate) :
{
    String literal;
    String lang=null;
    String datatype=null;
    Token t;
}
{
    (literal=parseQuotedString() ((<DOUBLE_CARET> datatype=parseResource()) | (("@" (t=<PN_LOCAL>)){lang=t.image;}))?
        {
      if (datatype==null) datatype=Prefixes.s_semanticWebPrefixes.get("rdf")+"PlainLiteral";
      if (lang==null) lang="";
      handler.handleLiteralTriple(subject, predicate, literal, lang, Datatype.create(datatype));
        }
    )
    |
    (literal=parseInteger(){handler.handleLiteralTriple(subject, predicate, literal, "", OWL2_DATATYPES.INTEGER.getDatatype());})
    |
    (literal=parseDouble(){handler.handleLiteralTriple(subject, predicate, literal, "", OWL2_DATATYPES.DOUBLE.getDatatype());})
    |
    (literal=parseDecimal(){handler.handleLiteralTriple(subject, predicate, literal, "", OWL2_DATATYPES.DECIMAL.getDatatype());})
    |
    (literal=parseBoolean(){handler.handleLiteralTriple(subject, predicate, literal, "", OWL2_DATATYPES.BOOLEAN.getDatatype());})
}


String parseInteger() :
{
    Token t;
}
{
    t=<INTEGER> {
        return t.image;
    }
    |
    t=<DIGIT> {
        return t.image;
    }
}

String parseDouble() :
{
    Token t;
}
{
    t=<DOUBLE> {
        return t.image;
    }
}

String parseDecimal() :
{
    Token t;
}
{
    t=<DECIMAL> {
        return t.image;
    }
}

String parseBoolean() :
{
    Token t;
}
{
    (t=<TRUE> | t=<FALSE>) {
        return t.image;
    }
}

String parseQuotedString() :
{
    String s;
}
{
    s=parseString() {
        return s;
    }
}


String parseString() :
{
    Token t;
    String rawString = "";
}
{
    (t=<STRING> {
        rawString = t.image.substring(1, t.image.length() - 1);
    }
    | t=<LONG_STRING> {
        rawString = t.image.substring(3, t.image.length() - 3);
     }) {
        return EscapeUtils.unescapeString(rawString);
     }
}

